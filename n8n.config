# Szczeg√≥≈Çowa konfiguracja automatyzacji n8n dla aplikacji Memcoin Tracker

## Instalacja i uruchomienie n8n

### Opcja 1: Lokalne uruchomienie

1. Zainstaluj n8n globalnie:
```bash
npm install -g n8n
```

2. Uruchom n8n:
```bash
n8n start
```

### Opcja 2: Uruchomienie za pomocƒÖ Docker (zalecane dla produkcji)

1. Utw√≥rz katalog dla danych n8n:
```bash
mkdir -p ~/.n8n
```

2. Uruchom kontener Docker:
```bash
docker run -it --rm \
  --name n8n \
  -p 5678:5678 \
  -v ~/.n8n:/home/node/.n8n \
  -e WEBHOOK_URL=http://localhost:5678/ \
  -e GENERIC_TIMEZONE="Europe/Warsaw" \
  n8nio/n8n
```

### Opcja 3: U≈ºycie docker-compose

1. Utw√≥rz plik `docker-compose.n8n.yml`:
```yaml
version: '3'

services:
  n8n:
    image: n8nio/n8n
    restart: always
    ports:
      - "5678:5678"
    environment:
      - N8N_PORT=5678
      - N8N_PROTOCOL=http
      - N8N_HOST=localhost
      - N8N_EDITOR_BASE_URL=http://localhost:5678
      - WEBHOOK_URL=http://localhost:5678/
      - TZ=Europe/Warsaw
      - N8N_ENCRYPTION_KEY=your-encryption-key
      - N8N_BASIC_AUTH_ACTIVE=true
      - N8N_BASIC_AUTH_USER=admin
      - N8N_BASIC_AUTH_PASSWORD=password
    volumes:
      - ~/.n8n:/home/node/.n8n
```

2. Uruchom us≈Çugi:
```bash
docker-compose -f docker-compose.n8n.yml up -d
```

## Konfiguracja kredencja≈Ç√≥w w n8n

Przed uruchomieniem przep≈Çyw√≥w pracy, nale≈ºy skonfigurowaƒá odpowiednie kredencja≈Çy:

### 1. Konfiguracja kredencja≈Ç√≥w API Memcoin Tracker

1. W interfejsie n8n przejd≈∫ do "Credentials" (Po≈õwiadczenia)
2. Kliknij "Add Credential" (Dodaj po≈õwiadczenie)
3. Wybierz typ "HTTP Request"
4. Wype≈Çnij formularz:
   - Name: Memcoin Tracker API
   - Authentication: None (API nie wymaga uwierzytelnienia dla podstawowych endpoint√≥w)
   - Nie zaznaczaj "Include default options"

### 2. Konfiguracja kredencja≈Ç√≥w CoinGecko API

1. W interfejsie n8n przejd≈∫ do "Credentials"
2. Kliknij "Add Credential"
3. Wybierz typ "HTTP Request"
4. Wype≈Çnij formularz:
   - Name: CoinGecko API
   - Authentication: Header Auth
   - Parameter Name: X-CoinGecko-API-Key
   - Parameter Value: [Tw√≥j klucz API CoinGecko]

### 3. Konfiguracja kredencja≈Ç√≥w Twitter API

1. W interfejsie n8n przejd≈∫ do "Credentials"
2. Kliknij "Add Credential"
3. Wybierz typ "Twitter"
4. Wype≈Çnij formularz z danymi z Twitter Developer Portal:
   - API Key: [Tw√≥j klucz API]
   - API Secret: [Tw√≥j klucz tajny API]
   - Access Token: [Tw√≥j token dostƒôpu]
   - Access Token Secret: [Tw√≥j tajny token dostƒôpu]

## Szczeg√≥≈Çowy opis poszczeg√≥lnych przep≈Çyw√≥w pracy

### 1. Od≈õwie≈ºanie danych memcoin√≥w

Ten przep≈Çyw pracy jest odpowiedzialny za regularne pobieranie aktualnych danych o memcoinach z CoinGecko i aktualizacjƒô bazy danych aplikacji.

**Wƒôz≈Çy:**
1. **Schedule Trigger** - Uruchamia workflow co godzinƒô
   - Mode: Basic
   - Interval: Every Hour
   - First Execution: Start Now
   - Weekdays: Monday-Sunday

2. **HTTP Request (CoinGecko)** - Pobiera dane z CoinGecko API
   - Method: GET
   - URL: https://api.coingecko.com/api/v3/coins/markets
   - Query Parameters:
     - vs_currency: usd
     - category: meme-token
     - order: market_cap_desc
     - per_page: 100
     - page: 1
     - sparkline: false
     - price_change_percentage: 24h

3. **Function** - Przekszta≈Çca dane
   ```javascript
   // Przekszta≈Çcamy dane na w≈Ça≈õciwy format
   const transformedData = items[0].json.map(coin => {
     return {
       json: {
         symbol: coin.symbol.toUpperCase(),
         name: coin.name,
         logo: coin.image,
         currentPrice: coin.current_price,
         priceChange24h: coin.price_change_24h || 0,
         priceChangePercentage24h: coin.price_change_percentage_24h || 0,
         marketCap: coin.market_cap || 0,
         volume24h: coin.total_volume || 0,
         circulatingSupply: coin.circulating_supply,
         totalSupply: coin.total_supply,
         ath: coin.ath,
         athDate: coin.ath_date
       }
     };
   });
   
   return transformedData;
   ```

4. **HTTP Request (App API)** - Wysy≈Ça dane do API aplikacji
   - Method: POST
   - URL: http://your-app-domain.com/api/coins/batch-update
   - Body: ={{$json}}
   - Headers:
     - Content-Type: application/json

5. **IF** - Warunek sprawdzajƒÖcy powodzenie
   - Value 1: {{$node["HTTP Request (App API)"].json.success}}
   - Value 2: true
   - Operation: Equal
   
6. **Slack (Success)** - Wysy≈Ça powiadomienie o sukcesie (opcjonalnie)
   - Channel: #memcoin-tracker-monitoring
   - Text: ‚úÖ Dane memcoin√≥w zosta≈Çy pomy≈õlnie zaktualizowane ({{$node["HTTP Request (App API)"].json.updatedCount}} monet)

7. **Slack (Error)** - Wysy≈Ça powiadomienie o b≈Çƒôdzie (opcjonalnie)
   - Channel: #memcoin-tracker-monitoring
   - Text: ‚ùå B≈ÇƒÖd podczas aktualizacji danych memcoin√≥w: {{$node["HTTP Request (App API)"].json.error}}

### 2. Analiza sentymentu spo≈Çeczno≈õci

Ten przep≈Çyw pracy zbiera i analizuje sentyment z medi√≥w spo≈Çeczno≈õciowych dla najpopularniejszych memcoin√≥w.

**Wƒôz≈Çy:**
1. **Schedule Trigger** - Uruchamia workflow co 6 godzin
   - Mode: Basic
   - Interval: Every X Hours
   - Value: 6
   - First Execution: Start Now
   - Weekdays: Monday-Sunday

2. **HTTP Request (Top Coins)** - Pobiera top memcoiny
   - Method: GET
   - URL: http://your-app-domain.com/api/coins
   - Query Parameters:
     - limit: 20
     - sort: marketCap
     - order: desc

3. **Function (Extract Coins)** - Wyodrƒôbnia monety z odpowiedzi
   ```javascript
   // Wyodrƒôbniamy top 10 monet pod wzglƒôdem kapitalizacji rynkowej
   const coins = items[0].json.coins.slice(0, 10);
   
   // Przekszta≈Çcamy na format u≈ºywany przez Twitter API
   return coins.map(coin => {
     return {
       json: {
         symbol: coin.symbol,
         name: coin.name,
         id: coin.id
       }
     };
   });
   ```

4. **Split In Batches** - Dzieli na partie do przetwarzania
   - Batch Size: 1
   - Options: Return all items at once

5. **Twitter (Recent Search)** - Wyszukuje tweety
   - Operation: Search Tweets
   - Search Text: {{$json.symbol}} (crypto OR memecoin OR token) -is:retweet
   - Include: Extended Tweet Fields
   - Result Type: Recent
   - Max Results: 100
   - Additional Fields:
     - Tweet Fields: created_at,public_metrics,entities
     - Expansions: author_id
     - User Fields: description,public_metrics

6. **Function (Analyze Sentiment)** - Analizuje sentyment tweet√≥w
   ```javascript
   // Proste s≈Çowniki dla analizy sentymentu
   const positiveKeywords = ['moon', 'bullish', 'gem', 'rocket', 'hodl', 'hold', 'gains', 'profit'];
   const negativeKeywords = ['dump', 'scam', 'rugpull', 'rug', 'ponzi', 'crash', 'bear', 'bearish', 'sell'];
   
   // Pobieramy tweety i symbol
   const tweets = items[0].json.statuses;
   const coin = items[0].json.query.replace(/\(.*\)/g, '').trim();
   
   // Analiza
   let positive = 0;
   let negative = 0;
   let neutral = 0;
   let totalEngagement = 0;
   
   const analyzedTweets = tweets.map(tweet => {
     const text = tweet.text.toLowerCase();
     
     const posMatches = positiveKeywords.filter(word => text.includes(word)).length;
     const negMatches = negativeKeywords.filter(word => text.includes(word)).length;
     
     let sentiment;
     if (posMatches > negMatches) {
       sentiment = 'positive';
       positive++;
     } else if (negMatches > posMatches) {
       sentiment = 'negative';
       negative++;
     } else {
       sentiment = 'neutral';
       neutral++;
     }
     
     // Obliczamy zaanga≈ºowanie
     const engagement = tweet.retweet_count * 2 + tweet.favorite_count + (tweet.reply_count || 0) * 1.5;
     totalEngagement += engagement;
     
     return { id: tweet.id_str, text, sentiment, engagement, created_at: tweet.created_at };
   });
   
   // Obliczamy ca≈Çkowity sentyment
   const totalTweets = positive + negative + neutral;
   let sentimentScore = 50; // Neutralna warto≈õƒá
   
   if (totalTweets > 0) {
     const positivePercentage = (positive / totalTweets) * 100;
     const negativePercentage = (negative / totalTweets) * 100;
     sentimentScore = Math.min(Math.max(50 + (positivePercentage - negativePercentage) / 2, 0), 100);
   }
   
   return {
     json: {
       symbol: coin,
       tweetCount: totalTweets,
       positive_count: positive,
       negative_count: negative,
       neutral_count: neutral,
       sentiment_score: sentimentScore,
       total_engagement: totalEngagement,
       average_engagement: totalTweets > 0 ? totalEngagement / totalTweets : 0,
       top_tweets: analyzedTweets.sort((a, b) => b.engagement - a.engagement).slice(0, 5)
     }
   };
   ```

7. **HTTP Request (Update Sentiment)** - Wysy≈Ça dane sentymentu do API
   - Method: POST
   - URL: http://your-app-domain.com/api/social/sentiment
   - Body: ={{$json}}
   - Headers:
     - Content-Type: application/json

### 3. Aktualizacja predykcji

Ten przep≈Çyw pracy uruchamia aktualizacjƒô modelu predykcyjnego dla wszystkich memcoin√≥w.

**Wƒôz≈Çy:**
1. **Schedule Trigger** - Uruchamia workflow co 12 godzin
   - Mode: Basic
   - Interval: Every X Hours
   - Value: 12
   - First Execution: Start Now
   - Weekdays: Monday-Sunday

2. **HTTP Request (Update Predictions)** - Wywo≈Çuje endpoint aktualizacji predykcji
   - Method: POST
   - URL: http://your-app-domain.com/api/predictions
   - Body: { "action": "updateAll" }
   - Headers:
     - Content-Type: application/json

3. **Wait** - Czeka 10 minut na zako≈Ñczenie aktualizacji
   - Wait Amount: 10
   - Unit: Minutes

4. **HTTP Request (Get Top Predictions)** - Pobiera najlepsze predykcje
   - Method: GET
   - URL: http://your-app-domain.com/api/predictions
   - Query Parameters:
     - limit: 10

5. **Function (Format Alert)** - Formatuje alert√≥w dla potencjalnych monet
   ```javascript
   // Pobieramy top predykcje
   const predictions = items[0].json;
   
   // Filtrujemy tylko monety z wysokim prawdopodobie≈Ñstwem sukcesu
   const highPotentialCoins = predictions.filter(p => p.successProbability >= 75);
   
   if (highPotentialCoins.length === 0) {
     return { json: { noHighPotential: true } };
   }
   
   // Tworzymy wiadomo≈õƒá z alertem
   let alertMessage = "üöÄ *Memcoiny z wysokim potencja≈Çem*\n\n";
   
   highPotentialCoins.forEach((coin, index) => {
     alertMessage += `${index + 1}. *${coin.name} (${coin.symbol})*\n`;
     alertMessage += `   Prawdopodobie≈Ñstwo sukcesu: ${coin.successProbability.toFixed(1)}%\n`;
     alertMessage += `   Sentyment spo≈Çeczno≈õci: ${coin.factors.socialSentiment.total.toFixed(1)}\n`;
     alertMessage += `   Wzrost spo≈Çeczno≈õci: ${coin.factors.communityGrowth.toFixed(1)}%\n\n`;
   });
   
   return {
     json: {
       message: alertMessage,
       coins: highPotentialCoins
     }
   };
   ```

6. **IF** - Sprawdza czy istniejƒÖ monety z wysokim potencja≈Çem
   - Value 1: {{$node["Function (Format Alert)"].json.noHighPotential}}
   - Value 2: true
   - Operation: Not Equal

7. **Slack** - Wysy≈Ça alert o monetach z wysokim potencja≈Çem (opcjonalnie)
   - Channel: #memcoin-opportunities
   - Text: {{$node["Function (Format Alert)"].json.message}}

8. **Telegram** - Wysy≈Ça alert na Telegram (opcjonalnie)
   - Bot: Memcoin Tracker Bot
   - Chat ID: [ID czatu lub kana≈Çu]
   - Text: {{$node["Function (Format Alert)"].json.message}}
   - Parse Mode: Markdown

### 4. Monitorowanie nag≈Çych zmian

Ten przep≈Çyw pracy monitoruje nag≈Çe zmiany cen i wolumenu, generujƒÖc odpowiednie alerty.

**Wƒôz≈Çy:**
1. **Schedule Trigger** - Uruchamia workflow co 30 minut
   - Mode: Basic
   - Interval: Every X Minutes
   - Value: 30
   - First Execution: Start Now
   - Weekdays: Monday-Sunday

2. **HTTP Request (Get Coins)** - Pobiera najnowsze dane o monetach
   - Method: GET
   - URL: http://your-app-domain.com/api/coins
   - Query Parameters:
     - limit: 100
     - refresh: true

3. **Function (Detect Changes)** - Wykrywa znaczƒÖce zmiany
   ```javascript
   const coins = items[0].json.coins;
   
   // Wykrywanie znaczƒÖcych zmian cen
   const priceAlerts = coins.filter(coin => {
     return Math.abs(coin.priceChangePercentage24h) >= 20; // 20% lub wiƒôcej zmiany
   }).map(coin => {
     const isPositive = coin.priceChangePercentage24h > 0;
     return {
       type: isPositive ? 'price_surge' : 'price_drop',
       symbol: coin.symbol,
       name: coin.name,
       change: coin.priceChangePercentage24h,
       currentPrice: coin.currentPrice,
       message: `${coin.name} (${coin.symbol}) ${isPositive ? 'wzr√≥s≈Ç o' : 'spad≈Ç o'} ${Math.abs(coin.priceChangePercentage24h).toFixed(2)}% w ciƒÖgu ostatnich 24h`
     };
   });
   
   // Wykrywanie znaczƒÖcych zmian wolumenu
   const volumeAlerts = coins.filter(coin => {
     // Sprawdzamy czy wolumen wzr√≥s≈Ç co najmniej 3x w por√≥wnaniu do ≈õredniej
     const volumeRatio = coin.volume24h / (coin.volume7d / 7);
     return volumeRatio >= 3;
   }).map(coin => {
     const volumeRatio = coin.volume24h / (coin.volume7d / 7);
     return {
       type: 'volume_spike',
       symbol: coin.symbol,
       name: coin.name,
       volumeRatio: volumeRatio,
       volume24h: coin.volume24h,
       message: `${coin.name} (${coin.symbol}) ma ${volumeRatio.toFixed(1)}x wy≈ºszy wolumen ni≈º ≈õrednia z 7 dni`
     };
   });
   
   // ≈ÅƒÖczymy wszystkie alerty
   const allAlerts = [...priceAlerts, ...volumeAlerts];
   
   return { json: { alerts: allAlerts } };
   ```

4. **IF** - Sprawdza czy sƒÖ jakie≈õ alerty
   - Value 1: {{$node["Function (Detect Changes)"].json.alerts.length}}
   - Value 2: 0
   - Operation: Larger

5. **HTTP Request (Create Alerts)** - Tworzy alerty w systemie
   - Method: POST
   - URL: http://your-app-domain.com/api/alerts/batch
   - Body: ={{$node["Function (Detect Changes)"].json.alerts}}
   - Headers:
     - Content-Type: application/json

## Automatyczna konfiguracja n8n jako us≈Çugi systemowej (Linux)

Aby uruchomiƒá n8n jako us≈Çugƒô systemowƒÖ, utw√≥rz plik konfiguracyjny us≈Çugi systemd:

1. Utw√≥rz plik `/etc/systemd/system/n8n.service`:
```
[Unit]
Description=n8n
After=network.target

[Service]
Type=simple
User=n8n
WorkingDirectory=/home/n8n
ExecStart=/usr/bin/n8n start
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
```

2. Utw√≥rz u≈ºytkownika n8n:
```bash
sudo adduser --system --group n8n
```

3. W≈ÇƒÖcz i uruchom us≈Çugƒô:
```bash
sudo systemctl enable n8n
sudo systemctl start n8n
```

4. Sprawd≈∫ status us≈Çugi:
```bash
sudo systemctl status n8n
```

## Aktualizacja przep≈Çyw√≥w pracy

Po konfiguracji przep≈Çyw√≥w pracy, mo≈ºesz eksportowaƒá je jako pliki JSON i przechowywaƒá w repozytorium aplikacji:

1. Eksportuj przep≈Çyw z interfejsu n8n:
   - Kliknij na przep≈Çyw pracy
   - Wybierz "Download"
   - Zapisz plik JSON

2. Przechowuj pliki JSON w katalogu `/n8n-workflows` projektu.

3. Opublikuj szablon logowania:
```bash
cp /path/to/your/project/n8n-workflows/logs.js ~/.n8n/nodes/
```

## Monitorowanie n8n

Aby monitorowaƒá stan n8n, mo≈ºna skonfigurowaƒá alerty za pomocƒÖ narzƒôdzi takich jak:

### Prometheus + Grafana

1. Zainstaluj eksporter n8n dla Prometheusa:
```bash
npm install -g n8n-prometheus
```

2. Uruchom eksporter:
```bash
n8n-prometheus
```

3. Skonfiguruj Prometheusa do pobierania metryk z n8n:
```yaml
scrape_configs:
  - job_name: 'n8n'
    static_configs:
      - targets: ['localhost:9842']
```

4. Skonfiguruj pulpit Grafana do monitorowania n8n.

### Heartbeat n8n

Utw√≥rz prosty przep≈Çyw pracy, kt√≥ry bƒôdzie uruchamiany co minutƒô i wysy≈Ça≈Ç sygna≈Ç do serwisu monitorujƒÖcego, takiego jak UptimeRobot:

1. **Schedule Trigger** - Uruchamia workflow co minutƒô
2. **HTTP Request** - Wysy≈Ça ping do serwisu monitorujƒÖcego
   - Method: GET
   - URL: [Link do monitorowania]

## RozwiƒÖzywanie problem√≥w

### Problem: Workflow nie uruchamia siƒô zgodnie z harmonogramem

1. Sprawd≈∫ logi n8n:
```bash
sudo journalctl -u n8n.service
```

2. Sprawd≈∫ ustawienia czasowe w n8n:
```bash
sudo docker exec -it n8n n8n --diagnose
```

3. Upewnij siƒô, ≈ºe strefa czasowa jest poprawnie ustawiona:
```bash
sudo docker exec -it n8n date
```

### Problem: B≈Çƒôdy po≈ÇƒÖczenia z API

1. Sprawd≈∫, czy API jest dostƒôpne:
```bash
curl -I http://your-app-domain.com/api/health
```

2. Sprawd≈∫ po≈õwiadczenia API:
```bash
sudo docker exec -it n8n n8n credential:list
```

3. Sprawd≈∫ logi n8n dla szczeg√≥≈Ç√≥w b≈Çƒôdu:
```bash
sudo docker exec -it n8n cat /home/node/.n8n/logs/n8n.log
```

### Problem: Wysoka u≈ºycie zasob√≥w

1. Ogranicz liczbƒô r√≥wnoleg≈Çych zada≈Ñ:
```bash
export N8N_PROCESS_CONCURRENCY=2
```

2. Zwiƒôksz przydzielone zasoby w docker-compose:
```yaml
services:
  n8n:
    # ...
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G
```

## Kopie zapasowe konfiguracji n8n

Wykonuj regularne kopie zapasowe konfiguracji n8n:

```bash
# Utw√≥rz katalog kopii zapasowych
mkdir -p ~/n8n-backups

# Wykonaj kopiƒô zapasowƒÖ konfiguracji
tar -czf ~/n8n-backups/n8n-backup-$(date +%Y%m%d).tar.gz ~/.n8n

# Opcjonalnie, zautomatyzuj za pomocƒÖ crona
echo "0 0 * * 0 tar -czf ~/n8n-backups/n8n-backup-\$(date +\%Y\%m\%d).tar.gz ~/.n8n" | crontab -
```

## Dodatkowe zasoby

- [Dokumentacja n8n](https://docs.n8n.io/)
- [Samouczki n8n](https://n8n.io/learn/)
- [Forum spo≈Çeczno≈õci n8n](https://community.n8n.io/)
- [GitHub n8n](https://github.com/n8n-io/n8n)